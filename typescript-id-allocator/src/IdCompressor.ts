import { IdCompressor as WasmIdCompressor } from "wasm-id-allocator";
import { assert } from "./copied-utils";
import {
	CompressedId,
	IdCreationRange,
	IIdCompressor,
	IIdCompressorCore,
	OpSpaceCompressedId,
	SerializedIdCompressor,
	SerializedIdCompressorWithNoSession,
	SerializedIdCompressorWithOngoingSession,
	SessionId,
	SessionSpaceCompressedId,
	StableId,
} from "./types";
import { currentWrittenVersion } from "./types/persisted-types/0.0.1";
import { generateStableId } from "./util";
import { getIds } from "./util/idRange";
import { createSessionId, fail } from "./util/utilities";

export const defaultClusterCapacity = WasmIdCompressor.get_default_cluster_capacity();

export class IdCompressor implements IIdCompressor, IIdCompressorCore {
	private readonly sessionTokens: Map<SessionId, number> = new Map();
	public readonly localSessionId: SessionId;

	private constructor(private readonly wasmCompressor: WasmIdCompressor) {
		this.localSessionId = wasmCompressor.get_local_session_id() as SessionId;
	}

	public static create(): IdCompressor;
	public static create(sessionId: SessionId): IdCompressor;
	public static create(sessionId?: SessionId): IdCompressor {
		const localSessionId = sessionId ?? createSessionId();
		const compressor = new IdCompressor(new WasmIdCompressor(localSessionId));
		return compressor;
	}

	/**
	 * The size of each newly created ID cluster.
	 */
	public get clusterCapacity(): number {
		return this.wasmCompressor.get_cluster_capacity();
	}

	/**
	 * Must only be set with a value upon which consensus has been reached. Value must be greater than zero and less than
	 * `IdCompressor.maxClusterSize`.
	 */
	public set clusterCapacity(value: number) {
		this.wasmCompressor.set_cluster_capacity(value);
	}

	private getOrCreateSessionToken(sessionId: SessionId): number {
		let token = this.sessionTokens.get(sessionId);
		if (token === undefined) {
			token = this.wasmCompressor.get_token(sessionId);
			// Will also catch NaN
			if (token > 0) {
				this.sessionTokens.set(sessionId, token);
			}
		}
		return token;
	}

	public finalizeCreationRange(range: IdCreationRange): void {
		const ids = getIds(range);
		if (ids === undefined) {
			return;
		}
		const { firstGenCount: first, lastGenCount: last, overrides } = ids;
		assert(overrides === undefined, "Overrides not yet supported.");
		this.wasmCompressor.finalize_range(range.sessionId, first, last - first + 1);
	}

	public takeNextCreationRange(): IdCreationRange {
		const wasmRange = this.wasmCompressor.take_next_range();
		let range: IdCreationRange;
		if (wasmRange.ids === undefined) {
			range = { sessionId: this.localSessionId };
		} else {
			const { first_local_gen_count, count } = wasmRange.ids;
			range = {
				sessionId: this.localSessionId,
				ids: {
					firstGenCount: first_local_gen_count,
					lastGenCount: first_local_gen_count + count - 1,
				},
			};
		}
		wasmRange.free();
		return range;
	}

	public generateCompressedId(override?: string): SessionSpaceCompressedId {
		return this.wasmCompressor.generate_next_id() as SessionSpaceCompressedId;
	}

	private idOrError<TId extends CompressedId>(idNum: number): TId {
		if (Object.is(idNum, Number.NaN)) {
			throw new Error(this.wasmCompressor.get_error_string());
		}
		return idNum as TId;
	}

	public normalizeToOpSpace(id: SessionSpaceCompressedId): OpSpaceCompressedId {
		return this.idOrError<OpSpaceCompressedId>(this.wasmCompressor.normalize_to_op_space(id));
	}

	public normalizeToSessionSpace(
		id: OpSpaceCompressedId,
		originSessionId: SessionId,
	): SessionSpaceCompressedId {
		let session_token = this.getOrCreateSessionToken(originSessionId);
		if (Object.is(session_token, Number.NaN)) {
			throw new Error(this.wasmCompressor.get_error_string());
		} else if (session_token === -1 && id < 0) {
			fail("No IDs have ever been finalized by the supplied session.");
		}
		let normalizedId = this.wasmCompressor.normalize_to_session_space(id, session_token);
		return this.idOrError<SessionSpaceCompressedId>(normalizedId);
	}

	public decompress(id: SessionSpaceCompressedId): string | StableId {
		return (
			this.tryDecompress(id) ?? fail("Compressed ID was not generated by this compressor.")
		);
	}

	public tryDecompress(id: SessionSpaceCompressedId): string | StableId | undefined {
		// TODO: log error string to telemetry if undefined
		return this.wasmCompressor.decompress(id);
	}

	public recompress(uncompressed: string): SessionSpaceCompressedId {
		return this.tryRecompress(uncompressed) ?? fail("Could not recompress.");
	}

	public tryRecompress(uncompressed: string): SessionSpaceCompressedId | undefined {
		// TODO: log error string to telemetry if undefined
		return this.wasmCompressor.recompress(uncompressed) as SessionSpaceCompressedId | undefined;
	}

	public serialize(withSession: true): SerializedIdCompressorWithOngoingSession;
	public serialize(withSession: false): SerializedIdCompressorWithNoSession;
	public serialize(withSession: boolean): SerializedIdCompressor {
		return {
			bytes: this.wasmCompressor.serialize(withSession),
			version: currentWrittenVersion,
		} as SerializedIdCompressor;
	}

	public dispose(): void {
		this.wasmCompressor.free();
	}

	public static deserialize(serialized: SerializedIdCompressorWithOngoingSession): IdCompressor;
	public static deserialize(
		serialized: SerializedIdCompressorWithNoSession,
		newSessionId: SessionId,
	): IdCompressor;
	public static deserialize(
		serialized: SerializedIdCompressor,
		sessionId?: SessionId,
	): IdCompressor {
		assert(
			serialized.version === currentWrittenVersion,
			"Unknown serialized compressor version found.",
		);
		const localSessionId = sessionId ?? (generateStableId() as SessionId);
		return new IdCompressor(WasmIdCompressor.deserialize(serialized.bytes, localSessionId));
	}
}
